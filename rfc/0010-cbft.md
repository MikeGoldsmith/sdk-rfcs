# Meta

 - RFC Name: Couchbase Full Text Search Index Query (FTS)
 - RFC ID: 0010-fulltext
 - Start Date: 2016-03-04
 - Owner: Michael Nitschinger
 - Current Status: Draft

# Summary
This RFC describes the SDK API and behavior exposure of the Couchbase Server Full Text Search (FTS) capabilities, shipping with Couchbase Server 4.5 ("watson"). It describes both the user-facing APIs, as well as the protocol level details which are needed to implement the APIs.

# Motivation
Couchbase Server 4.5 ships with FTS support and to provide first-class support for our users and customers we need to properly expose it in the SDK APIs.

Note that this RFC does only deal with index querying, not index maintenance and administration.

# General Design
The general design of using FTS is to expose a "fluent API", similar to other newer features like subdoc. The fluent pattern works very well in the FTS case because the user needs to craft the request out of a list of (sometimes complex) options. A properly designed API can guide the user the right way and also prevent invalid query option inputs, by having constructors take the mandatory parameters and have optional parameters introduced through setters that can be chained.

## 1. Query Type Overview

There are different types of queries which can be executed, some of them (compound queries) contain other queries in them. They all provide a common set of options and then each one has a unique option set. The following provides an overview of the supported query types by the server. Each of them will be detailed later in the request building section.

Simple Queries:

 - **Match Query:** A match query analyzes the input text and uses that analyzed text to query the index.
 - **Match Phrase Query:** The input text is analyzed and a phrase query is built with the terms resulting from the analysis.
 - **Fuzzy Query:** A fuzzy query is a term query that matches terms within a specified edit distance (Levenshtein distance).
 - **Prefix Query:** The prefix query finds documents containing terms that start with the provided prefix.
 - **Regexp Query:** Finds documents containing terms that match the specified regular expression.
 - **String Query:** The query string query allows humans to describe complex queries using a simple syntax.

Range Queries:

 - **Date Range Query:** The date range query finds documents containing a date value in the specified field within the specified range.
 - **Numeric Range Query:** The numeric range query finds documents containing a numeric value in the specified field within the specified range.

Compound Queries:

 - **Conjunction Query:** Result documents must satisfy all of the child queries.
 - **Disjunction Query:** Result documents must satisfy a configurable min number of child queries.
 - **Boolean Query:** The boolean query is a useful combination of conjunction and disjunction queries.

## 2. High Level API Overview
This section describes how the overall API looks like (to be expanded).

For both bucket and cluster level, the approach is the same. Right now only Bucket level is defined in this RFC.

```java
bucket.query(SearchQuery[, SearchParams]);
```

All query types described below must implement the `SearchQuery` marker interface or base class (including compound queries since they can be nested too).

Here is an example of a String query with some search params:

```java
bucket.query(new StringQuery("description:awesome").boost(2), new SearchParams().limit(5))
```

If idiomatic by the language, it makes sense to provide static factory methods (or similar helpers) to guide the user in the right direction since there are many different query options available. So for example the `SearchQuery` can contain factory methods in a form like this:

```java
bucket.query(SearchQuery.string("+water +abv:>10"), new SearchParams().limit(5))
```

This removes cognitive load, since the user only needs to remember "SearchQuery" and will have all supported query methods available immediately.

## 3. Request Query Options

### 3.1. Search Request Params
All options described in this section are not bound to a specific search option, but rather treated as a separate param set as an optional argument. They affect the query as a whole, independent of the actual search method (including compound queries) used.

They are part of the `SearchParams` object which can be used optionally by the user.

If not explicitly provided by the user, **the default settings indicated below should be applied by the SDK on every request** (for example to make sure the server timeout is always passed).

`new SearchParams().limit(1).skip(5).explain()`

#### Limit
The `limit` option limits the number of matches returned from the complete result set. The actual HTTP query field is called `size`, but to match it with N1QL and Views it makes sense to name it similarly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `limit(int limit)` | `size` | JSON Number | - | >  0, if not set no size is used (no default value) |

**Examples:** `.limit(10)`

#### Skip
The `skip` option indicates how many matches are skipped on the result set before starting to return the matches. The actual HTTP query field is called `from`, but to match it with N1QL and Views it makes sense to name it similarly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `skip(int skip)` | `from` | JSON Number | - | >  0, if not set no size is used (no default value) |

**Examples:** `.skip(5)`

#### Explain
The boolean `explain` field triggers inclusion of additional search result score explanations.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `explain()` | `explain` | JSON Boolean | - | -|



#### Highlighting
This option allows the user to specify optional highlighting of the result set. It allows to both set the `style` and the `fields` to highlight. Highlighting is disabled by default.


| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `highlight(HighlightStyle style, [String... fields])` | `highlight` | JSON Object `{"style": "foo", "fields": ["fa", "fb"]}` | - | -|

The `HighlightStyle` is an enumeration (or similar with a fixed set of possible values) which describes the highlighters the Server supports. The following options are available:

```java
enum HighlightStyle {
  HTML, // maps to "html" on the wire
  ANSI  // maps to "ansi" on the wire
}
```

The `style` is required, but if no `field` is provided FTS will just highlight all fields where there is a match.

**Examples:** `.highlight(HighlightStyle.HTML)`, `.highlight(HighlightStyle.HTML, "description", "name")`

#### Fields
This option describes a list of field values which should be retrieved for result documents, provided they
were stored while indexing.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `fields(String... fields)` | `fields` | JSON Array (of strings) `...,"fields": ["a", "b"],...` | - | -|

**Examples:** `.fields("description", "name")`

#### Facets
Facets allow to aggregate information collected on a particular result set. Currently there are three different types of facets supported:

 - Term Facet: A term facet categorizes the matching documents into categories given by a particular field. The `size`/`limit` parameter drives how many categories are returned (only the top n categories are returned).
 - Numeric Range Facet: A numeric range facet works by the user defining their own numeric ranges. The facet then counts how many of the matching documents fall into a particular range for the faceted field.
 - Date Range Facet: same as numeric, but on dates instead of numbers.

Note that range boundaries are all inclusive, and ranges can overlap (so a document can fall eg. in two overlapping date ranges).

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `facets()`    | `facets`     | JSON Object of Objects `{name: {facet}, name: {facet}...}` | - | For a single facet, either `numeric_ranges` or `date_ranges` is allowed. If omitted it is a term facet. |

The 3 types of facets have corresponding methods on the `facets()` builder:

| Facet Type | Builder Method | Range Wire Format |
| ---------- | -------------- | ------------ |
| term       | `facets().addTerm(String name, String field, int limit)` | - |
| numeric    | `facets().addNumeric(String name, String field, int limit, NumericRange... ranges)` | `[ { "name": name of range (string), "min": inclusive lower bound (float), "max": inclusive upper bound (float) } ]` |
| date       | `facets().addDate(String name, String field, int limit, DateRange... ranges)` | `[ { "name": name of range (string), "start": "2011-08-30T13:22:53.108Z", "end": "... quoted string rfc 3339" } ]`  |

At a minimum, each `{facet}` has a `field` and a `size`. The size drives the number of facets/categories returned. Numeric facets also have an array `numeric_ranges` of `{numericRange}` objects.
Date faces instead have an array `date_ranges` of `{dateRange}` objects. See following wire examples for term, numeric and date:

```json
"facets": {
    "myTermFacet": {
        "field": "fieldName",
        "size": 3
    }
}
```

Name, min and max are optional, although either min or max should be provided):

```json
"facets": {
    "myNumericFacet": {
        "field": "fieldName",
        "size": 2,
        "numeric_ranges": [
            { "name":"range1", "min": 0.1, "max": 3.0 },
            { "name":"range2", "min": 3.1 }
        ]
    }
}
```

```json
"facets": {
    "myDateFacet": {
        "field": "fieldName",
        "size": 2,
        "date_ranges": [
            { "name":"old", "end": "2016-01-01T00:00:00"},
            { "name":"thisYear", "start": "2016-01-01T00:00:01"},
            { "name":"theYear2011", "start": "2011-01-01T00:00:00", "end": "2011-12-31T23:59:59"}
        ]
    }
}
```

**Examples:** `.facets().addTerm("type", "type", 5)`,
`.facets().addNumeric("strength", "abv", 3, numeric("strong", 5), numeric("middle", 3.1, 4.99), numeric("light", 0, 3.0))`,
`.facets().addDate("age", "updated", 2, date("old", null, "2010-01-31T00:00:00"), date("recent", 2010-02-01T00:00:00, 2016-01-01T00:00:00"))`

Since multiple facets can be used in one request, subsequent calls to `facets()` are additive (as long as they have different names).

#### Server Side Timeout
The server side timeout allows to specify an upper boundary of request execution so
that it potentially doesn't run infinitely.

Note that like N1QL, the SDK must pass the client side timeout, if not overridden by
the user down automatically, since there is no point in running the request if no one
is listening anymore.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `serverSideTimeout(long timeout)` | `ctl.timeout` | JSON Number (positive and > 0) in milliseconds | client side timeout (75 seconds) | must be greater than 0 |

**Examples:** `.timeout(long timeout)` // or equivalent timeout abstraction whatever is used in the SDK

#### Query Consistency

TODO, note that REQUEST_PLUS is slated for spock ([MB-18428](https://issues.couchbase.com/browse/MB-18428)).This should look like the stuff we have in N1QL, abstracting over the mutation tokens with `consistentWith`.

### 3.2. Common Query Options
The following list of options are available for every type of query below (including compound queries).

#### Boosting
The boost parameter is used to increase the relative weight of a clause (with a boost greater than 1) or decrease the relative weight (with a boost between 0 and 1).

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `boost(double boost)` | `query.boost` | JSON Number | - | `>= 0` |

**Examples:** `.boost(1.5)`, `.boost(0.3)`

### 3.3. Match Query Options
A match query is like a term query, but the input text is analyzed first. An attempt is made to use the same analyzer that was used when the field was indexed.

```java
new MatchQuery("salty beers").analyzer("custom_analyzer").boost(1.0).fuzziness(2)
```

#### Match
The input string to be matched against. The match string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `new MatchQuery(String match)` | `query.match` | JSON String | - | must not be empty |

**Examples:** `new MatchQuery("salty beers")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

#### Analyzer

Analyzers are used to transform input text into a stream of tokens for indexing. The Server comes with built-in analyzers and the users can create their own. The string here is the name of the analyzer used.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `analyzer(String analyzer)` | `query.analyzer` | JSON String | - | - |

**Examples:** `.analyzer("my_cool_analyzer")`

#### Prefix Length
Theis parameter can be used to require that the term also have the same prefix of the specified length.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `prefixLength(int length)` | `query.prefix_length` | JSON Number | - | if 0 not used, must never be negative. |

**Examples:** `.prefixLength(5)`

#### Fuzziness
The match query can optionally perform fuzzy matching. If the fuzziness parameter is set to a non-zero integer the analyzed text will be matched with the specified level of fuzziness.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `fuzziness(int fuzziness)` | `query.fuzziness` | JSON Number | - | - |

**Examples:** `.fuzziness(1)`

### 3.4. Match Phrase Query Options
The input text is analyzed and a phrase query is built with the terms resulting from the analysis. This type of query searches for terms occurring in the specified positions and offsets. This depends on term vectors, which are consulted to determine phrase distance.

```java
new MatchPhraseQuery("salty beers").analyzer("custom_analyzer").boost(1.0)
```

#### Match Phrase
The input phrase to be matched against. The match phrase string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `new MatchPhraseQuery(String matchPhrase)` | `query.match_phrase` | JSON String | - | - |

**Examples:** `new MatchPhraseQuery("salty beers")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

#### Analyzer

Analyzers are used to transform input text into a stream of tokens for indexing. The Server comes with built-in analyzers and the users can create their own. The string here is the name of the analyzer used.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `analyzer(String analyzer)` | `query.analyzer` | JSON String | - | - |

**Examples:** `.analyzer("my_cool_analyzer")`

### 3.5. Fuzzy Query Options
A fuzzy query is a term query that matches terms within a specified edit distance (Levenshtein distance). Also, you can optionally specify that the term must have a matching prefix of the specified length.

Here is an example of a `fuzzy` query:

```java
new FuzzyQuery("my term").fuzziness(3)
```

#### Term
The input term to be matched against. The term string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String term` | `query.term` | JSON String | - | - |

**Examples:** `new FuzzyQuery("my term")`

#### Prefix Length
The `prefix_length` parameter can be used to require that the term also have the same prefix of the specified length.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `prefixLength(int length)` | `query.prefix_length` | JSON Number | - | if 0 not used, must never be negative. |

**Examples:** `.prefixLength(5)`

#### Fuzziness
The match query can optionally perform fuzzy matching. If the fuzziness parameter is set to a non-zero integer the analyzed text will be matched with the specified level of fuzziness.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `fuzziness(int fuzziness)` | `query.fuzziness` | JSON Number | - (the server picks 2 as the default) | boost must be greater or equal to 0 |

**Examples:** `.fuzziness(1)`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### 3.6. Prefix Query Options
The prefix query finds documents containing terms that start with the provided prefix.
```java
new PrefixQuery("foo")
```

#### Prefix
The prefix to be analyzed and used against. The prefix string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String prefix` | `query.prefix` | JSON String | - | - |

**Examples:** `new PrefixQuery("foo")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### 3.7. Regexp Query Options
Regexp query finds documents containing terms that match the specified regular expression.

Here is an example of a `regexp` query:

```java
new RegexpQuery("[A-Za-z0-9]")
```

#### Regexp
The regexp to be analyzed and used against. The regexp string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String regexp` | `query.regexp` | JSON String | - | - |

**Examples:** `new RegexpQuery("[A-Za-z0-9]")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### 3.8. String Query Options
The query string query allows humans to describe complex queries using a simple syntax.

```java
new StringQuery("description:water and some other stuff").boost(1)
```

#### Match
The query string to be analyzed and used against. The query string is required.


| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String query` | `query.query` | JSON String | - | - |

**Examples:** `new StringQuery("description:water and some other stuff")`

### 3.9. Numeric Range Query Options
The numeric range query finds documents containing a numeric value in the specified field within the specified range. Either min or max can be omitted, but not both.

#### Min
The lower end of the range, inclusive by default.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `min(float min[, boolean inclusive])` | `query.min` & `query.inclusive_min` | JSON Number & JSON Boolean | min omitted, inclusive = true | - |

**Examples:** `.min(10, false)`

#### Max
The higher end of the range, exclusive by default.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `max(float max[, boolean inclusive])` | `query.max` & `query.inclusive_max` | JSON Number & JSON Boolean | min omitted, inclusive = false | - |

**Examples:** `.max(500, true)`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### 3.10. Date Range Query Options
The date range query finds documents containing a date value in the specified field within the specified range. Either start or end can be omitted, but not both.

#### Start
The start date of the range, (inclusive by default ??todo).

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `start(String start[, boolean inclusive])` | `query.start` & `query.inclusive_start` | JSON String & JSON Boolean | start omitted, inclusive = true | - |

**Examples:** `.start("date format supported", false)`

#### End
The end date of the range, (exclusive by default ??todo).

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `end(String end[, boolean inclusive])` | `query.start` & `query.inclusive_end` | JSON String & JSON Boolean | start omitted, inclusive = false | - |

**Examples:** `.end("date format supported", true)`

#### DateTime Parser
This field enables one to specify a custom date time parser.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `dateTimeParser(String name)` | `query.datetime_parser` | JSON String | - | - |

**Examples:** `.dateTimeParser("customParser")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### 3.11. Compound Queries - Conjunction Query
The conjunction query is a compound query. The result documents must satisfy all of the child queries. It is possible to recursively nest compound queries.

```java
new ConjunctionQuery(SearchQuery queries....)
```

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) SearchQuery... queries` | `query.conjuncts` | JSON Array | - | - |

**Examples:** `new ConjunctionQuery(new StringQuery(...), new MatchQuery(...))`


### 3.12. Compound Queries - Disjunction Query
The disjunction query is a compound query. The result documents must satisfy a configurable min number of child queries. By default this min is set to 1.

```java
new DisjunctionQuery(SearchQuery queries....)
```

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) SearchQuery... queries` | `query.disjuncts` | JSON Array | - | - |

**Examples:** `new DisjunctionQuery(new StringQuery(...), new MatchQuery(...))`

#### Min
The minimum number of child queries that must be satisfied for the disjunction query.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `min(int min)` | `query.min` | JSON Number | - | - |

**Examples:** `.min(2)`


### 3.13. Compound Queries - Boolean Query
The boolean query is a useful combination of conjunction and disjunction queries. A boolean query takes three lists of queries:

 - must - result documents must satisfy all of these queries.
 - should - result documents should satisfy these queries.
 - must not - result documents must not satisfy any of these queries.

```java
new BooleanQuery().must(SearchQuery).should(SearchQuery).mustNot(SearchQuery)
```

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `must(SearchQuery query)` | `query.must` | JSON Object | - | - |
| `should(SearchQuery query)` | `query.should` | JSON Object | - | - |
| `mustNot(SearchQuery query)` | `query.must_not` | JSON Object | - | - |

## 4. Search Response
Like with N1Ql and Views the search response can be separated into the actual returned rows and associated metadata.

```
SearchQueryResult {
  "status": {
    "total": long
    "failed": long
    "successful": long
    "errors": [ string, ... ] //optional
  },
  "request": {JSON object}
  "hits": [ {SearchQueryRow}, ... ]
  "total_hits": long
  "max_score": double
  "took": long
  "facets": {Facets}
}
```

| Method        | Response Path | Wire Type              | Example |
| ------------- | ------------- | ---------------------- | ------- |
| `status()`    | `status`      | JSON Object            | { "total": 2, "failed": 1, "successful": 1", "errors": [ "error1" ] } |
| `took()`      | `took`        | JSON Number            | 984127591 |
| `totalHits()` | `total_hits`  | JSON Number            | 6039 |
| `maxScore()`  | `max_score`   | JSON Number            | 0.35303675962587 |
| `hits()`      | `hits`        | JSON Array of Objects  | - |
| `facets()`    | `facets`      | JSON Object of Objects | - |

**TODO: code representation, additional boolean status method?**


### 4.1. Status and Errors
**TODO**

### 4.2. Hits
Hits are the proper results of the search. They are represented in the JSON response as an array of objects, which we'll call `SearchQueryRow` (to maintain the theme of the "row" found in both view and N1QL queries):

```
SearchQueryRow {
  "index": string
  "id": string
  "score": double
  "locations": {JSON object}
  "fragments": {JSON object}
  "fields": {JSON object}
}
```
Each hit is relative to a document and report its `id` and the `index` that was used. A `score` for the hit conveys the relevance of the hit (things like distance from the original term when fuzziness is set can impact the score for example).

Then each hit has sub-objects in 3 categories: `locations` indicate where the search terms matched inside the document (in terms of offsets), `fragments` are related to highlighting (giving an excerpt of the document where the matching terms are highlighted) and `fields` give the complete value of the included fields where matches occurred (if these fields are stored in the index).

#### Locations
An example of the `locations` *JSON object* is:

```json
"locations": {
        "description": {
          "beer": [
            {
              "pos": 3,
              "start": 11,
              "end": 15,
              "array_positions": null
            },
            {
              "pos": 59,
              "start": 325,
              "end": 329,
              "array_positions": null
            }
          ]
        },
        "name": {
          "beer": [
            {
              "pos": 3,
              "start": 11,
              "end": 15,
              "array_positions": null
            }
          ]
        }
      }
```

As we can see, this is a nested structure:

 1. At top level, JSON objects. The attribute name of each object is the name of the `field` it relates to.
 2. In this JSON object we'll have arrays of hit locations. Each array's attribute name is the term it relates to, as found inside that particular field's index. This is the indexed `term` (as opposed to both the query term and the actual occurrence, called a *token*).
 3. The array of hit locations can contain multiple locations. Each is a JSON object with the following structure:

```
HitLocation {
    "pos": long
    "start": long
    "end": long
    "array_positions": ???
}
```
Note that in the index mapping configuration, if a field is _not included in term vectors_, the locations could be omitted. **TODO** investigate on that and provide more details.

The proposed pseudocode counterpart for the whole `locations` section is a nested `Map` (or equivalent in the target language, eg. hash, associative array...). The lowest level would be defined as a `HitLocation` class (or equivalent):

```java
Map<String, Map<String, HitLocation>> locations() { }

class HitLocation {
	pos long @NotNull
	start long @NotNull
	end long @NotNull
	arrayPositions []long @Nullable
}

Map field1 = new Map();
field1.put("beer", new HitLocation(3, 11, 15), new HitLocation(59, 325, 329));

Map field2 = new Map();
field2.put("beer", new HitLocation(3, 11, 15));

Map locations = new Map();
locations.put("description", field1);
locations.put("name", field2);
```

> An adhoc class or structure can be substituted to the nested map, as long as the following operations are possible:
> 
>  - iteration over fields
>  - retrieval of a all terms for a particular field (`allLocations.get(field)`)
>  - iteration over terms inside a single field
>  - retrieval of a particular term inside a single field (`oneFieldLocations.get(term)`)
>  - as a consequence, retrieval of a particular term inside a particular field (`allLocations.get(field).get(term)`)

#### Fragments
An example of the `fragments` *JSON object* is:

```json
"fragments": {
        "description": [
          "…rsey <mark>Beer</mark> Co. is dedicated to crafting quality <mark>beer</mark> for all; from the occasional <mark>beer</mark> drinker to the <mark>beer</mark> aficionado. We believe that good products come from good people, and strive to do our very bes…"
        ],
        "name": [
          "New Jersey <mark>Beer</mark> Company"
        ]
      }
```

It is made of a single JSON object in which each attribute is a field's name (into which some terms matched). The value of each attribute is an array of excerpts from the document, into which hits are highlighted by being put between `<mark>` tags.

The array can contain multiple entries (eg. if the hits are far apart in the document). **TODO clarify when**.

> **NOTE**: To appear, a field must have been included in the scope of the search and be **stored** in the index, **including term vectors**.

The proposed pseudocode counterpart for the whole `fragments` section is a multi-value `Map` (or equivalent in the target language, eg. hash, associative array...), each entry containing a `sequence` of `strings` (eg. list, array...):

```java
Map<String, String[]> fragments() { }

String[] field1 = new String[] { "…rsey <mark>Beer</mark> Co" };
String[] field2 = new String[] { "New Jersey <mark>Beer</mark> Company" };

Map fragments = new Map();
fragments.put("description", field1);
fragments.put("name", field2);
```
> An adhoc class or structure can be substituted to this simple representation as long as the following operations are possible:
> 
>  - iterate over fields
>  - get all fragments for a given field

#### Fields
An example of the `fields` *JSON object* is:

```json
"fields": {
        "description": "New Jersey Beer Co. is dedicated to crafting quality beer for all; from the occasional beer drinker to the beer aficionado.",
        "name": "New Jersey Beer Company"
      }
```

The fields section outputs complete values from the fields that were requested at query time. It contains one attribute per requested field, mapping to the string of the complete field's content.

> **NOTE**: For the section to appear, some fields must have been requested in the top level `fields` section of the query and the corresponding fields must be **stored** in the index.

The proposed pseudocode counterpart for the whole `fields` section is a `Map` (or equivalent in the target language, eg. hash, associative array...), each entry being the `field -> string value` association:

```java
Map<String, String> fields() { }

Map fields = new Map();
fields.put("description", "New Jersey Beer Co is dedicated to crafting...");
fields.put("name", "New Jersey Beer Company");
```
> An adhoc class or struct shouldn't be needed for this direct `field -> value` association as most languages will have an equivalent. If that was not the case however, the adhoc class/structure would need to allow the retrieval of a value, given a field's name.


### 4.3. Facets
The `facets` part of the result, a sibling to `hits`, contains information relative to the facets the user asked for. If no `facets` section was provided in the query, this section is omitted.

Note that the whole `facets` section **is a single JSON object**. The `name` of each facet, which is defined at query time by the user, is represented in the attribute names.

An individual facet result has both metadata and details, as each facet can define ranges into which results are categorized. The JSON representation of a single facet's results looks like this:

```
FacetResult {
    "field": string
    "total": long
    "missing": long
    "other": long
    "terms": [ {TermRange}, ... ] <1>
    "numeric_ranges": [ {NumericRange}, ...] <1>
    "date_ranges": [ {DateRange}, ... ] <1>
}
```
(1) all mutually exclusive (`terms`, `numeric_ranges` and `date_ranges` cannot be combined).

See the following JSON example:

```
"facets": {
    "category": { <1>
      "field": "style",
          ...
      "terms": [ ... ]
    },
    "strength": { <2>
      "field": "abv",
          ...
      "numeric_ranges": [ ... ]
    },
    "updateRange": { <3>
      "field": "updated",
          ...
      "date_ranges": [ ... ]
    }
  }
```
We omitted part of the section, but this shows that we have 3 facets: a _term_ facet **(1)** named "category", a _numeric_ facet **(2)** named "strength" and a _date_ facet **(3)** named "updateRange".

The section could be represented by a `Map` (or equivalent, eg. associative array).

```java
Map<String, FacetResult> facets();
```

It could also be represented by any other adhoc class or structure, as long as the following operations are possible:

 - iteration of all the facets
 - retrieval of a facet by name

In code, individual facet results could be represented by an interface and three concrete implementations, one for each facet type:

```java
interface FacetResult {
    String name();
    String field();
    long total();
    long missing();
    long other();
}
```

Note the `name` is made part of the `FacetResult`, so that it can be used in isolation.

#### Term Facet Results
```java
class TermFacetResult implements FacetResult {
	//... all from FacetResult, plus:
	List<TermRange> terms();
}
```

The JSON structure of each **term range** is:

```
TermRange {
	"name": string //the "category" or term
	"count": long //how many times this term was seen
}
```
This can be directly mapped to a `TermRange` class or the appropriate structure in the target language.

When requesting a term facet, the user provides a `size` and a `field`. Each term in this field will be considered as a unique range (a "bucket"), and the `TermFacetResult` will contain the first _size_ terms, ordered by occurrence count. So in a `TermRange`, the `name` is the "category" or term and the `count` is the number of times this term was seen.

#### Numeric Range Facet Results
```java
class NumericFacetResult implements FacetResult {
	//... all from FacetResult, plus:
	List<NumericRange> numericRanges();
}
```

The JSON structure of each **numeric range** is:

```
NumericRange {
    "name": string //the name given to the range in facet query 
    "min": long //the minimum value considered in the range (inclusive)
    "max": long //the maximum value considered in the range (inclusive)
    "count": long //how many terms were included in this range?
}
```
This can be directly mapped to a `NumericRange` class or the appropriate structure in the target language.

When requesting a numeric facet, the user defines ranges (also called buckets) and gives them names. All bounds are inclusive, so a term can be categorized into several overlapping buckets.

#### Date Range Facet Results
```java
class DateFacetResult implements FacetResult {
	//... all from FacetResult, plus:
	List<DateRange> dateRanges();
}
```

The JSON structure of each **date range** is:

```
DateRange {
    "name": string //the name given to the range in facet query
    "start": string //the minimum date ("YYYY-MM-DD HH:MM:SS") in range (inclusive)
    "end": string //the maximum date in range (inclusive)
    "count": long //how many terms were included in this range?
}
```
This can be directly mapped to a `DateRange` class or the appropriate structure in the target language.

When requesting a date facet, the user defines ranges (also called buckets) and gives them names. All bounds are inclusive, so a term can be categorized into several overlapping buckets.


# Language Specifics
In this section, the abstract design parts need to be broken down on the SDK level by each maintainer and signed off eventually.

| Generic | NET         | Java   | NodeJS | Go  | C   | PHP | Python | Ruby |
| ------- | ----------- | ------ | ------ | --- | --- | --- | ------ | ---- |


# Unresolved Questions
- Bleve/CBFT supports more options than right now officially documented/specified in this RFC. We need to check if those should be included as well.
- I wonder if its possible that the compound queries can be put into one API?
- the response also returns the request, seems a little wasteful on network bandwith?
	<br/>**=>** this is actually the request that FTS ended up actually executing. Due to optimizations and parsing, it could be different from the one passed in by the user. In such case, exposing it might help users debug the situation (especially if they receive results that they don't expect).

# Signoff
If signed off, each representative agrees both the API and the behavior will be implemented as specified.

| Language | Representative | Date       |
| -------- | -------------- | ---------- |
| Java     | Michael N.     | 01.01.1960 |
