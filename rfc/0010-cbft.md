# Meta

 - RFC Name: Couchbase Full Text Search Index Query (FTS)
 - RFC ID: 0010-fulltext
 - Start Date: 2016-03-04
 - Owner: Michael Nitschinger
 - Current Status: Draft

# Summary
This RFC describes the SDK API and behavior exposure of the Couchbase Server Full Text Search (FTS) capabilities, shipping with Couchbase Server 4.5 ("watson"). It describes both the user-facing APIs, as well as the protocol level details which are needed to implement the APIs.

# Motivation
Couchbase Server 4.5 ships with FTS support and to provide first-class support for our users and customers we need to properly expose it in the SDK APIs.

Note that this RFC does only deal with index querying, not index maintenance and administration.

# General Design
The general design of using FTS is to expose a "builder API", similar to other newer features like subdoc. The builder pattern works very well in the FTS case because the user needs to craft the request out of a list of (sometimes complex) options. A properly designed builder can guide the user the right way and also prevent invalid query option inputs.

## Query Type Overview

There are different types of queries which can be executed, some of them (compound queries) contain other queries in them. They all provide a common set of options and then each one has a unique option set. The following provides an overview of the supported query types by the server. Each of them will be detailed later in the request building section.

Simple Queries:

 - **Match Query:** A match query analyzes the input text and uses that analyzed text to query the index.
 - **Match Phrase Query:** The input text is analyzed and a phrase query is built with the terms resulting from the analysis.
 - **Fuzzy Query:** A fuzzy query is a term query that matches terms within a specified edit distance (Levenshtein distance).
 - **Prefix Query:** The prefix query finds documents containing terms that start with the provided prefix.
 - **Regexp Query:** Finds documents containing terms that match the specified regular expression.
 - **String Query:** The query string query allows humans to describe complex queries using a simple syntax.

Range Queries:

 - **Date Range Query:** The date range query finds documents containing a date value in the specified field within the specified range.
 - **Numeric Range Query:** The numeric range query finds documents containing a numeric value in the specified field within the specified range.

Compound Queries:

 - **Conjunction Query:** Result documents must satisfy all of the child queries.
 - **Disjunction Query:** Result documents must satisfy a configurable min number of child queries.
 - **Boolean Query:** The boolean query is a useful combination of conjunction and disjunction queries.

## High Level API Overview
This section describes how the overall API looks like (to be expanded).

For both bucket and cluster level, the approach is the same. Right now only Bucket level is defined in this RFC.

```java
bucket.query(SearchQuery[, SearchParams]);
```

All query types described below must implement the `SearchQuery` marker interface or base class (including compound queries since they can be nested too).

Here is an example of a String query with some search params:

```java
bucket.query(new StringQuery("description:awesome").boost(2), new SearchParams().limit(5))
```

If idiomatic by the language, it makes sense to provide static factory methods (or similar helpers) to guide the user in the right direction since there are many different query options available. So for example the `SearchQuery` can contain factory methods in a form like this:

```java
bucket.query(SearchQuery.string("+water +abv:>10"), new SearchParams().limit(5))
```

This removes cognitive load, since the user only needs to remember "SearchQuery" and will have all supported query methods available immediately.

## Request Query Options

### Search Request Params
All options described in this section are not bound to a specific search option, but rather treated as a sparate param set as an optional argument. They affect the query as a whole, independent of the actual search method (including compound queries) used.

They are part of the `SearchParams` object which can be used optionally by the user. If not used, default settings as noted should be applied on every request (for example to make sure the server timeout is always passed).

`new SearchParams().limit(1).skip(5).explain()`

#### Limit
The `limit` option limits the number of matches returned from the complete result set. The actual HTTP query field is called `size`, but to match it with N1QL and Views it makes sense to name it similarly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `limit(int limit)` | `size` | JSON Number | - | >  0, if not set no size is used (no default value) |

**Examples:** `.limit(10)`

#### Skip
The `skip` option indicates how many matches are skipped on the result set before starting to return the matches. The actual HTTP query field is called `from`, but to match it with N1QL and Views it makes sense to name it similarly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `skip(int skip)` | `from` | JSON Number | - | >  0, if not set no size is used (no default value) |

**Examples:** `.skip(5)`

#### Explain
The boolean `explain` field triggers inclusion of additional search result score explanations.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `explain()` | `explain` | JSON Boolean | - | -|



#### Highlighting
This option allows the user to specify optional highlighting of the result set. It allows to both set the `style` and the `fields` to highlight. Highlighting is disabled by default.


| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `highlight(HighlightStyle style, [String... fields])` | `highlight` | JSON Object `{"style": "foo", "fields": ["fa", "fb"]}` | - | -|

The `HighlightStyle` is an enumeration (or similar with a fixed set of possible values) which describes the highlighters the Server supports. The following options are available:

```
enum HighlightStyle {
  HTML, // maps to "html" on the wire
  ANSI  // maps to "ansi" on the wire
}
```

The `style` is required, but if no `field` is provided FTS will just highlight all fields where there is a match.

**Examples:** `.highlight(HighlightStyle.HTML)`, `.highlight(HighlightStyle.HTML, "description", "name")`

#### Fields
This option describes a list of field values which should be retrieved for result documents, provided they
were stored while indexing.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `fields(String... fields)` | `fields` | JSON Array (of strings) `...,"fields": ["a", "b"],...` | - | -|

**Examples:** `.fields("description", "name")`

#### Facets
Facets allow to aggregate information collected on a particular result set. Currently there are three different types of facets supported:

 - Term Facet: A term facet counts up how many of the matching documents have a particular term in a particular field.
 - Numeric Range Facet: A numeric range facet works by the user defining their own numeric ranges. The facet then counts how many of the matching documents fall into a particular range for a particular field.
 - Date Range Facet: same as numeric, but on dates instead of numbers.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `facets().addTerm(String name, String field, int limit)`, `facets().addRange(String name, String field, int limit, Range... ranges)` | `facets` | JSON Object `{name: {"size": limit, "field": field, [numeric_ranges: [NR, NR], date_ranges: [DR, DR]]}, name: {...}}` | - | Either no, or just `numeric_ranges` or just `date_ranges` is allowed per facet. |

Here is how the `numeric_ranges` and `date_ranges` look like in wire format:

Numeric (name, min and max are optional, although either min or max should be provided):
```
{"name": name (string), "min": min (float), "max": max (float)}
```

Date:
```
{"name": name (string), start: "2011-08-30T13:22:53.108Z", end: "... quoted string rfc 3339", startString: "..", endString: ".."}
```

**Examples:** `.facets().addTerm("type", "type", 5)`, `.facets().addRange("abv", "abv", 6, numeric("high", 7), numeric("low", 7)).addRange(...)`

Since multiple facets can be used in one request, subsequent calls to `facets()` are additive.

On the `addRange()` facet it is important that either numeric or date ranges are used per facet, mixing is not possible.

#### Server Side Timeout
The server side timeout allows to specify an upper boundary of request execution so
that it potentially doesn't run infinitely.

Note that like N1QL, the SDK must pass the client side timeout, if not overridden by
the user down automatically, since there is no point in running the request if no one
is listening anymore.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `serverSideTimeout(long timeout)` | `ctl.timeout` | JSON Number (positive and > 0) in milliseconds | client side timeout (75 seconds) | must be greater than 0 |

**Examples:** `.timeout(long timeout)` // or equivalent timeout abstraction whatever is used in the SDK

#### Query Consistency

TODO, note that REQUEST_PLUS is slated for spock ([MB-18428](https://issues.couchbase.com/browse/MB-18428)).This should look like the stuff we have in N1QL, abstracting over the mutation tokens with `consistentWith`.

### Common Query Options
The following list of options are available for every type of query below (including compound queries).

#### Boosting
The boost parameter is used to increase the relative weight of a clause (with a boost greater than 1) or decrease the relative weight (with a boost between 0 and 1).

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `boost(double boost)` | `query.boost` | JSON Number | - | `>= 0` |

**Examples:** `.boost(1.5)`, `.boost(0.3)`

### Match Query Options
A match query is like a term query, but the input text is analyzed first. An attempt is made to use the same analyzer that was used when the field was indexed.

```java
new MatchQuery("salty beers").analyzer("custom_analyzer").boost(1.0).fuzziness(2)
```

#### Match
The input string to be matched against. The match string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `new MatchQuery(String match)` | `query.match` | JSON String | - | must not be empty |

**Examples:** `new MatchQuery("salty beers")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

#### Analyzer

Analyzers are used to transform input text into a stream of tokens for indexing. The Server comes with built-in analyzers and the users can create their own. The string here is the name of the analyzer used.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `analyzer(String analyzer)` | `query.analyzer` | JSON String | - | - |

**Examples:** `.analyzer("my_cool_analyzer")`

#### Prefix Length
Theis parameter can be used to require that the term also have the same prefix of the specified length.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `prefixLength(int length)` | `query.prefix_length` | JSON Number | - | if 0 not used, must never be negative. |

**Examples:** `.prefixLength(5)`

#### Fuzziness
The match query can optionally perform fuzzy matching. If the fuzziness parameter is set to a non-zero integer the analyzed text will be matched with the specified level of fuzziness.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `fuzziness(int fuzziness)` | `query.fuzziness` | JSON Number | - | - |

**Examples:** `.fuzziness(1)`

### Match Phrase Query
The input text is analyzed and a phrase query is built with the terms resulting from the analysis. This type of query searches for terms occurring in the specified positions and offsets. This depends on term vectors, which are consulted to determine phrase distance.

```java
new MatchPhraseQuery("salty beers").analyzer("custom_analyzer").boost(1.0)
```

#### Match Phrase
The input phrase to be matched against. The match phrase string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `new MatchPhraseQuery(String matchPhrase)` | `query.match_phrase` | JSON String | - | - |

**Examples:** `new MatchPhraseQuery("salty beers")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

#### Analyzer

Analyzers are used to transform input text into a stream of tokens for indexing. The Server comes with built-in analyzers and the users can create their own. The string here is the name of the analyzer used.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `analyzer(String analyzer)` | `query.analyzer` | JSON String | - | - |

**Examples:** `.analyzer("my_cool_analyzer")`

### Fuzzy Query Options
A fuzzy query is a term query that matches terms within a specified edit distance (Levenshtein distance). Also, you can optionally specify that the term must have a matching prefix of the specified length.

Here is an example of a `fuzzy` query:

```java
new FuzzyQuery("my term").fuzziness(3)
```

#### Term
The input term to be matched against. The term string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String term` | `query.term` | JSON String | - | - |

**Examples:** `new FuzzyQuery("my term")`

#### Prefix Length
The `prefix_length` parameter can be used to require that the term also have the same prefix of the specified length.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `prefixLength(int length)` | `query.prefix_length` | JSON Number | - | if 0 not used, must never be negative. |

**Examples:** `.prefixLength(5)`

#### Fuzziness
The match query can optionally perform fuzzy matching. If the fuzziness parameter is set to a non-zero integer the analyzed text will be matched with the specified level of fuzziness.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `fuzziness(int fuzziness)` | `query.fuzziness` | JSON Number | - (the server picks 2 as the default) | boost must be greater or equal to 0 |

**Examples:** `.fuzziness(1)`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### Prefix Query Options
The prefix query finds documents containing terms that start with the provided prefix.
```java
new PrefixQuery("foo")
```

#### Prefix
The prefix to be analyzed and used against. The prefix string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String prefix` | `query.prefix` | JSON String | - | - |

**Examples:** `new PrefixQuery("foo")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### Regexp Query Options
Regexp query finds documents containing terms that match the specified regular expression.

Here is an example of a `regexp` query:

```java
new RegexpQuery("[A-Za-z0-9]")
```

#### Regexp
The regexp to be analyzed and used against. The regexp string is required.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String regexp` | `query.regexp` | JSON String | - | - |

**Examples:** `new RegexpQuery("[A-Za-z0-9]")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### String Query Options
The query string query allows humans to describe complex queries using a simple syntax.

```java
new StringQuery("description:water and some other stuff").boost(1)
```

#### Match
The query string to be analyzed and used against. The query string is required.


| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) String query` | `query.query` | JSON String | - | - |

**Examples:** `new StringQuery("description:water and some other stuff")`

### Numeric Range Query Options
The numeric range query finds documents containing a numeric value in the specified field within the specified range. Either min or max can be omitted, but not both.

#### Min
The lower end of the range, inclusive by default.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `min(float min[, boolean inclusive])` | `query.min` & `query.inclusive_min` | JSON Number & JSON Boolean | min omitted, inclusive = true | - |

**Examples:** `.min(10, false)`

#### Max
The higher end of the range, exclusive by default.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `max(float max[, boolean inclusive])` | `query.max` & `query.inclusive_max` | JSON Number & JSON Boolean | min omitted, inclusive = false | - |

**Examples:** `.max(500, true)`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### Date Range Query Options
The date range query finds documents containing a date value in the specified field within the specified range. Either start or end can be omitted, but not both.

#### Start
The start date of the range, (inclusive by default ??todo).

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `start(String start[, boolean inclusive])` | `query.start` & `query.inclusive_start` | JSON String & JSON Boolean | start omitted, inclusive = true | - |

**Examples:** `.start("date format supported", false)`

#### End
The end date of the range, (exclusive by default ??todo).

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `end(String end[, boolean inclusive])` | `query.start` & `query.inclusive_end` | JSON String & JSON Boolean | start omitted, inclusive = false | - |

**Examples:** `.end("date format supported", true)`

#### DateTime Parser
This field enables one to specify a custom date time parser.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `dateTimeParser(String name)` | `query.datetime_parser` | JSON String | - | - |

**Examples:** `.dateTimeParser("customParser")`

#### Field
If a field is specified, only terms in that field will be matched. This can also affect the used analyzer if one isn't specified explicitly.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `field(String field)` | `query.field` | JSON String | - | - |

**Examples:** `.field("fieldname")`

### Compound Queries - Conjunction Query
The conjunction query is a compound query. The result documents must satisfy all of the child queries. It is possible to recusrively nest compound queries.

```
new ConjunctionQuery(SearchQuery queries....)
```

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) SearchQuery... queries` | `query.conjuncts` | JSON Array | - | - |

**Examples:** `new ConjunctionQuery(new StringQuery(...), new MatchQuery(...))`


### Compound Queries - Disjunction Query
The disjunction query is a compound query. The result documents must satisfy a configurable min number of child queries. By default this min is set to 1.

```
new DisjunctionQuery(SearchQuery queries....)
```

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `(constructor argument) SearchQuery... queries` | `query.disjuncts` | JSON Array | - | - |

**Examples:** `new DisjunctionQuery(new StringQuery(...), new MatchQuery(...))`

#### Min
The minimum number of child queries that must be satisfied for the disjunction query.

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `min(int min)` | `query.min` | JSON Number | - | - |

**Examples:** `.min(2)`


### Compound Queries - Boolean Query
The boolean query is a useful combination of conjunction and disjunction queries. A boolean query takes three lists of queries:

 - must - result documents must satisfy all of these queries.
 - should - result documents should satisfy these queries.
 - must not - result documents must not satisfy any of these queries.

```
new BooleanQuery().must(SearchQuery).should(SearchQuery).mustNot(SearchQuery)
```

| Builder Name | Request Path | Wire Type | Default | Constraints |
| ------------ | ------------ | --------- | ------- | ----------- |
| `must(SearchQuery query)` | `query.must` | JSON Object | - | - |
| `should(SearchQuery query)` | `query.should` | JSON Object | - | - |
| `mustNot(SearchQuery query)` | `query.must_not` | JSON Object | - | - |

## Search Response
Like with N1Ql and Views the search response can be separated into the actual returned rows and associated metadata.

(todo: facets)

```
SearchQueryResult {
  took: long
  totalHits: long
  maxScore: double
  hits: []SearchQueryRow,
}
```

| Method | Response Path | Wire Type | Example |
| ------ | ------------- | --------- | ------- |
| `took()` | `took` | JSON Number | 984127591 |
| `totalHits()` | `total_hits` | JSON Number | 6039 |
| `maxScore()` | `max_score` | JSON Number | 0.35303675962587 |
| `hits()`| `hits` | JSON Array of Objects | - |

```
SearchQueryRow {
  id: string
  score: double
  // TODO: more stuff, here need to follow up with fts team on the response api spec
}
```

# Language Specifics
In this section, the abstract design parts need to be broken down on the SDK level by each maintainer and signed off eventually.

| Generic | .NET         | Java   | NodeJS | Go | C | PHP | Python | Ruby |
| ------- | ------------ | ------ | ------ | -- | - | --- | ------ | ---- |
| foo()   | foo<dynamic> | Foo<D> | ...... | .. | . | ... | ...... | .... |

# Unresolved Questions
- Bleve/CBFT supports more options than right now officially documented/specified in this RFC. We need to check if those should be included as well.
- I wonder if its possible that the compound queries can be put into one API?
- the response also returns the request, seems a little wasteful on network bandwith?
- Facets need to be handled in the response object

# Signoff
If signed off, each representative agrees both the API and the behavior will be implemented as specified.

| Language | Representative | Date       |
| -------- | -------------- | ---------- |
| Java     | Michael N.     | 01.01.1960 |
